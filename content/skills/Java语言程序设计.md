# Java语言程序设计

![Java](./pictures/Java.png)

## 一、Java基础语法

### 1.Hello,World

```java
public class Hello{
    public static void main(String[] args){
        System.out.println("Hello,World!");
    }
}
```

#### （1）注释

```Java
//单行注释
/*
    多行
    注释
    多行注释不允许嵌套
*/
/**
    文档
    注释
    命令：javadoc -d dir_name -author -version hello.java  自动生成程序的帮助文档
*/
```

#### （2）标识符的命名

* 标识符命名规则
	* 只能由26个英文字母大小写、0-9、\_或$组成，且不能以数字开头
	* 不能是关键字或保留字，但是可以包含关键字或保留字
	* Java严格区分大小写，不限制标识符的长度，但是标识符内不能包含空格
* 标识符命名规范（推荐但不强制）
	* 包名：多单词组成时所字母都小写
	* 类名、接口名：多单词组成时每个单词的首字符大写
	* 变量名、方法名：多单词组成时，除第一个单词之外每一个单词的首字母都大写
	* 常量名：每一个字母都大写，多单词时每个单词之间用_连接
* 注意：**Java应用类的包名不能以java.开头**，否则执行时就会抛出异常

### 2.数据类型

#### （1）变量

> 变量：其实就是内存中的一段存储区域，能够在同一个范围内不断变化，是程序的最基本的存储单元
* Java中的变量必须先声明之后使用，因为只有声明后这个变量才会被在内存中加载
* 其中**局部变量声明之后不会被自动初始化**，因此在使用之前必须先进行初始化（赋初值）
* 变量都是定义在其作用域内的，只在这个作用域内有效，其实作用域就是声明这个变量时所在的大括号内
* 同一个作用域内不可以声明两个同名的变量，同一个变量不可以在同一个作用域内多次定义
> 变量的分类
* 局部变量：定义在方法的形参列表或方法体内的变量
* 成员变量（属性）：定义在类的{ }内部的变量
> 成员变量 VS 局部变量
* 相同点
  * 定义变量的格式相同：数据类型 变量名 = 变量值;
  * 都要求先声明，后使用
  * 两种变量都有其对应的作用域
* 不同点
  * 在类中声明的位置不同——成员变量直接定义在类的{}内；局部变量声明在方法内、方法形参、代码块内、构造器形参和构造器内
  * 关于权限修饰符——成员变量可以在声明时通过使用权限修饰符，指明其权限；局部变量不可以使用权限修饰符
  * 默认初始化值的情况——成员变量，根据其数据类型都有对应的默认初始化值；局部变量没有默认初始化值，我们在调用局部变量之前一定要显式赋值（形参在调用时赋值即可）
  * 在内存中加载的位置——非static的成员变量加载到堆空间中，static的成员变量加载到方法区；局部变量都加载到栈空间

#### （2）基本数据类型

> 数值型：
* 整数类型：byte（1个字节）、short（2个字节）、int（4个字节）、long（8个字节）
* 浮点类型：float（4个字节）、double（8个字节）
* 说明：
	* 如果程序中给一个基本数据类型变量的值超过其数据类型的存储范围，则**编译不过**
	* 整型变量通常使用int：因为在java中int是整型数据的默认存储方式，所以long型变量赋值时必须加以L或l结尾
	* 浮点型变量通常使用double：因为在java中double是浮点型数据的默认存储方式，所以float型变量赋值时必须加以F或f结尾
	* 浮点型数据可以利用’e’作为科学计数法中的’10’后面跟’10’的次数，来使用科学计数法的表示数值
> 字符型：
* char(2个字节)
* char c1 = ‘a’;
* 说明：
	* java采用unicode编码，支持汉字、单位数字等各种字符
	* 表示字符常量的单引号内只能有一个字符，否则报语法错误，编译不过
	* 可以使用转义字符'\n'、'\t'等
> 布尔型
* boolean
* boolean类型的变量只能取两个值之一：**true** 或 **false**

#### （3）引用数据类型

* 类：class
* 接口：interface
* 数组：[ ]
* 说明：
	* 字符串类型（String）实际上属于类类型，也就属于引用类型
	* 引用类型的变量，只可能存储两类值：null、地址值（指针）

#### （4）不同基本数据类型变量之间的运算

> **自动数据类型转换**：容量小的数据类型的变量与容量大的数据类型的数据类型的变量做运算时，结果自动提升为容量大的数据类型。
* 容量从小到大排序：(byte 、char、 short) < int < long < float < double
* 说明：
	* 此处的容量大小是表示的数的范围容量大小，而不是占用的内存空间的大小
	* 当byte、char、short三个类型的变量之间进行运算时，**结果的类型都一定会是int**，同类型相互运算时也是这样
> 强制数据类型转换
* double doubleVar = 12.9;
* int intVar = (int)doubleVar;
* 说明：
	* 浮点型向整形强制类型转换，采用的是**直接截取浮点数整数部分的方式(俗称“截断操作”)**，而不是四舍五入，转换之后数据的精度可能降低，称为精度损失
	* 变量向数值范围不够的数据强制类型转换，并不会编译报错
	* 整型常量默认是int型，浮点型常量默认是double型

#### （5）String变量的使用

* String属于引用数据类型
```Java
String stringVar = "HelloWorld";
System.out.println(stringVar);
```
* 提取一个字符串中的某个字符：
```Java
char charVar_1 = stringVar.charAt(0);
char charVar_2 = stringVar.charAt(1);
char charVar_3 = stringVar.charAt(2);
char charVar_4 = stringVar.charAt(3);
char charVar_5 = stringVar.charAt(4);
```
* String类型值的*双引号内可以只有一个字符，也可以什么都没有*，但是char类型的*单引号''内必须有且仅有一个字符，该字符可以是一个空格*，但是**不能什么都没有，也不能有超过1个字符**
* String可以分别和8种基本的数据类型进行运算，但是都只能是连接运算

### 3.运算符

#### （1）算术运算符

|运算符   |   运算     |        范例        |     结果      |
|--------|------------|--------------------|---------------|
|  +     |    正号    |         +3         |       3       |
|   -    |    负号    |     b = 4; - b     |      -4       |
|   +    |     加     |        5+5         |      10       |
|   -    |     减     |       6 - 4        |       2       |
|   *    |     乘     |       3 * 4        |      12       |
|   /    |     除     |       5 / 5        |       1       |
|   %    |    取模    |       7 % 5        |       2       |
|   ++   |    自增    |  var = 10; var++   |      11       |
|   --   |    自减    |  var = 10; var--   |       9       |
|   +    | 字符串拼接 | "hello," + "world" | "hello,world"  |
* 整数间做除法运算会得到商，即整数之间的除法运算的结果只能是整数（就是**把实际运算结果的小数点及小数点后面的全部去掉**），而不能得到精确的结果
* 如果想要通过整数之间的除法而得到精确结果，那么就需要
* 整数间做取模运算得到余数，**结果的符号与被模数保持一致**
* 自增自减运算符
	* 左自增和左自减是在变量发挥作用之前使得变量的值增加或减去1
	* 右自增和右自减是在变量发挥作用之后使得变量的值增加或减去1
	* 最后的结果，变量的值都会增加或减去1
	* 自增与自减不会改变变量本身的数据类型

#### （2）赋值运算符

|  符号   |    运算   |        范例        |     结果      |
|--------|-----------|--------------------|----------------|
|   +    |    正号    |         +3         |       3       |
|   +=   |    负号    |     b = 4; - b     |      -4       |
|   -=   |     加     |        5+5         |      10       |
|   =    |     乘     |       3 * 4        |      12       |
|   %=   |     除     |       5 / 5        |       1       |
|   \*=   |     减     |       6 - 4        |       2       |
* 当赋值运算符两端数据类型不一致时，可以使用自动类型转换或强制类型转换原则进行处理
* 赋值运算表达式的返回值（运算结果）就是赋值号所传递的那个值，所以**赋值运算支持连续赋值**

#### （3）比较运算符

* 运算符： \>  <  ==  !=  >=  =<  instanceof()
* 比较运算符的运算结果只能是布尔类型的值（**true**、**false**）

#### （4）逻辑运算符

|  符号  |     运算     |        范例        |     结果      |
| ------ | ------------|--------------------|---------------|
|   &    |    逻辑与    |         +3         |       3       |
|   \|    |    逻辑或    |     b = 4; - b     |      -4       |
|   !    |    逻辑非    |        5+5         |      10       |
|   &&   |    短路与    |       6 - 4        |       2       |
|  \|\|  |    短路或    |       3 * 4        |      12       |
|    ^   |    逻辑异或  |       5 / 5        |       1       |
* 逻辑运算符只能对布尔型变量进行操作
* 短路就意味着如果仅凭运算符前面的表达式就可以准确得出本次逻辑运算的结果，那么就不会再执行运算符右侧的表达式来获得该表达式的返回值再用于逻辑判断
* 实际开发之中一般优先使用短路

#### （5）位运算符

|运算符 |操作      |
|------|----------|
| <<   | 左移     |
| \>>   | 右移     |
| \>>>  | 无符号右移|
|  &   | 与运算    |
|  \|   | 或运算    |
|  ^   | 异或运算  |
|  ~   | 取反运算  |

#### （6）三元运算符 

* **(条件表达式) ? 表达式1 : 表达式2**
* 如果条件表达式的值为true则执行表达式1，否则执行表达式2
* 条件表达式的结果为布尔类型的值

#### （7）运算符优先级

|运算符 | 结合性   |
|------|----------|
| <<   | 左移     |
| \>>   | 右移     |
| \>>>  | 无符号右移 |
|  &   | 与运算    |
|  \|   | 或运算    |
|  ^   | 异或运算  |
|  ~   | 取反运算  |

### 4.流程控制

#### （1）if—else分支

* 结构1：
```java
if(条件表达式){
  程序语句块1;
}
```
* 结构2：
```java
if(条件表达式){
  程序语句块1;
}else{
  程序语句块2;
}
```
* 结构3：
```java
if(条件表达式1){
  程序语句块1;
}else if(条件表达式2){
  程序语句块2;
}else{
    程序语句块3;
}
```
* 注意事项：
	* else结构是可选的
	* 如果多个条件表达式之间是“互斥的关系”（或没有交集的关系），那个判断或执行语句声明在上面还是下面，是无所谓的

#### （2）switch—case分支

```java
switch(表达式){
  case 常量1: 当条件表达式的值为常量1时执行的语句;break;
  case 常量2: 当条件表达式的值为常量1时执行的语句;break;
  .
  .
  .
  case 常量N: 当条件表达式的值为常量1时执行的语句;break;
  default: 当条件表达式的值不是以上的任何一个常量值时执行的语句;
}
```
* 如果想要实现多选一的操作，那么应该在每一个case中都使用break;语句
* 表达式的值只能是这6中类型之一：byte、short、char、int、枚举类型(JDK5.0开始枚举类型才允许作为表达式)、String类型(JDK7.0开始String类型才允许作为表达式)
* case后面绝对禁止写范围
* default结构时可选的
* 如果结构中的多个case的执行语句相同，则可以考虑合并
* 同一个结构中不同的case下不可以重复定义同名变量

#### （3）循环结构

* for循环
```java
for(初始化条件;循环条件;迭代条件){
    循环体;
}
```
* while循环
```java
while(条件表达式){
    程序语句块;
}
```
* do-while循环
```java
do{
  循环体;
  迭代条件;
}while(循环条件);
//循环体至少会被执行一次
```
* 特殊关键字的使用
	* break：用于switch-case结构和循环结构，用于直接跳出switch语句或结束当前循环
	* continue：仅用于循环结构，用于结束当前循环并直接开始下一次循环
	* 这两个关键字语句的后面都不能有需要执行的语句
* 说明：
	* for循环和while循环完全可以相互转化
	* for循环和while循环的初始化条件的作用范围不一样
		* for循环：初始化条件只在循环内有效
		* while循环：可以对循环控制变量在整个程序范围内产生影响（因为其循环控制变量是在循环结构外部定义的，其生命周期为从变量生命声明开始到整个方法体的末尾结束）
	* 结束循环的方法
		* 在循环体内执行break;语句
		* 循环条件为false
	* 嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中
		* A成为内层循环，B称为外层循环
		* 内层循环遍历1遍，则外层循环执行一次

### 5.数组

#### （1）关于Java数组

* 数组属于引用类型的，数组的元素既可以是基本数据类型也可以是引用数据类型。
* 创建数组对象会在内存中开辟一整块连续空间，而数组名中引用的是这块连续空间的首地址。
* 数组的长度一旦确定，就不能修改。
* 数组的分类: 
	* 按照维度：一维数组、二维数组、三维数组......
	* 按照数据类型：基本数据类型元素的数组、引用数据类型元素的数组（即对象数组）

#### （2）一维数组的使用

* 声明和初始化
```java
//声明：
int[] arrayVar;

//静态初始化：数组的初始化和数据元素的赋值同时进行
int[] arrayVar = new int[]{1123,3432,34343,23232};

//动态初始化：数组的初始化和数据元素的赋值分开进行
int[] arrayVar = new int[4];

/*注意事项：
	1.声明并初始化操作，只有上面的两种情况是正确的,不能把两种方式混合在一起
	2.数组一旦初始化完成，其长度就确定了
*/
```
* 调用指定位置的元素
```java
arrayVar[0] = 10;
arrayVar[1] = 20;
arrayVar[2] = 30;

/*注意事项：
	1.数组的下标是从0开始的，到“数组的长度-1”结束
	2.如果数组的角标超出“数组的长度-1”时，编译时不会报错，但是运行时会报错
*/
```
* 获取数组长度
```java
//数组有一个属性叫做length
System.out.println("arrayVar.length");//打印出数组的长度
```
* 遍历数组
```Java
for(int i=0;i < arrayVar.length;i++){
	visit(arrayVar[i]);
}
```
* 数组元素的默认初始化值
	* 整型数据元素：0
	* 浮点型数据元素：0.0
	* 字符型数据元素：0或\u0000而非'0'，输出时空格效果，但是实际上并非空格
	* 布尔类型数据元素：false
	* 字符串型数据元素：null而不是"null"，包括字符串型数据元素在内的所有引用类型的数据元素的默认初始化值都是null
* 内存解析
&emsp;&emsp;作为局部变量的数组名变量存储在栈(stack)中，数组的数据元素存储在堆里组成一段连续的内存空间。数组名变量通过指向这段连续的内存空间首地址值，而与这段内存空间产生联系。  
&emsp;&emsp;对于一个已经经过了初始化了的数组名变量，它原先关联于一段内存空间A，我们再开辟一段新的内存空间B，并将它赋值给这个数组名变量，那么这个数组名变量就会关联于这段新的内存空间B，而不再关联于原来的那一段内存空间A，B中的数组元素可以通过这个数组名调用，A中的数组元素不再能通过这个数组名进行调用，这段内存空间A就会是一段没有被指针指向的内存空间也就成为了垃圾，从而会在在某一个不确定的时间被Java的垃圾回收机制自动销毁。

#### （3）二维数组的使用

> &emsp;&emsp;数据元素的数据类型为数组的数组称为二维数组。其本质上是一维数组A作为另一个一维数组B的元素而存在，从数组底层的运行机制来看，其实没有多维数组。
* 声明和初始化
```Java
//声明：
int[][] arrayVar;

//静态初始化：
int[][] arrayVar = new int[][]{{1,3,2,1},{3,42,1,2,23},{1,2},{2,5,5}};  正确

//动态初始化:
	//二维数组每个子数组的长度可以互不相同
	//二维数组在进行动态初始化时子数组的长度可以不指定，但是必须指定外层数组的数组长度
int[][] arrayVar = new int[3][];  //正确
int[][] arrayVar = new int[][4];  //错误
```
* 调用数组的指定位置的元素
```Java
//调取外层数组元素：
arrayVar[行下标]

//调取内层数组元素：
arrayVar[行下标][列下标]
```
* 获取数组的长度
	* 因为二维数组本质上是存储着一个又一个数组名变量的一维数组，所以二维数组的长度就是这个二维数组的外层数组的长度，即"行角标+1"。 
	* 可以通过length属性进行查看
* 数组元素的遍历
```Java
//使用二层嵌套循环结构
```
* 二维数组元素的默认初始化值
	* 情况一：指定了内层数组的长度
		* 外层数组元素：地址值
			* \[I@7ea987ac : 1个"\["代表这是一个一维数组，@后面就是16进制形式的地址值
			* \[\[I@12a3a380 ：2个"\["代表这是一个二维数组，@后面就是16进制形式的地址值
		* 内层数组元素：默认初始化值的情况与一维数组元素的默认初始化值的情况一致
	* 情况二：未指定内层数组的长度
		* 外层数组元素：null，无论是什么类型的二维数组，只要内层数组的长度在数组初始化时没有指定，那么外层数组的默认初始化值就一定是null
		* 内层数组元素：没有默认初始化值，不能调用，强行使用的话，编译不会报错，但是执行会报错：使用了一个空指针
* 二维数组的内存解析
  * 静态初始化
  * 动态初始化

声明了一个二维数组名变量之后

#### （4）Arrays工具类的使用：

```Java
import java.util.Arrays;

boolean equalsJudge = Arrarys.equals(arraysVar_1,arrayVar_2);
//比较两个数组是否相同，相同则返回true,不相同则返回false

String detials = Arrays.toString(arrayVar);
//输出指定数组内的所有元素

Arrays.fill(arrayVar,10);
//把指定数组中的所有元素都替换成10

Arrays.sort(arrayVar);
//实现将数组内的元素从左到右按照从小到大进行排列

int index = Arrays.binarySearch(arrayVar,23);
//二分法查找，只针对于有序的数组，输出所查的元素的对应的角标，如果说这个数组内存在多个相同的目标值则会返回最左侧的目标值的地址，如果数组内没有目标值则会返回一个负数
```

#### （5）数组常见异常：

* 数组下标越界：ArrayIndexOutOfBoundsExcetion
```Java
int[] arrayVar =  new int[10];
System.out.println(arrayVar[10]);
```
* 空指针异常：NullPointerException
```Java
//情况一：
int[] arrayVar = new int[]{1,2,3};
arrayVar[0] = null;
System.out.println(arrayVar[0]);

//情况二：
int[][] arrayVar = new int[4][];
System.out.println(arrayVar[0][0]);

//情况三：
String[] arrayVar = new String[]{"AA","BB","CC"};
arrayVar[0] = null;
System.out.println(arrayVar[0].toString());
```

## 二、Java面向对象

> 学习面向对象的三大主线
* Java类及类的成员：**属性**、**方法**、**构造器**；代码块、内部类
* 面向对象的三大特征：封装性、继承性、多态性（、抽象性）
* 其它关键字：this、super、static、final、abstract、interface、package、import等

### 1.Java基本元素：类和对象

#### （1）类的设计，也就是对类的成员设计

```java
class TestClass{
	//属性（成员变量、field、域、字段）
	String field1;
	int field2;

	//方法（成员方法、函数、method）
	public void method1(){
		System.out.println("这是方法1");
	}
	public void method2(){
		System.out.println("这是方法2");
	}
}
```
|属性的数据类型                |默认初始化值|
|-----------------------------|-----------|
|整型（byte、short、int、long）|0          |
|浮点型（float、double）       |0.0        |
|字符型（char）                |0（或'\u0000'）|
|布尔型（boolean）             |false        |
|引用数据类型（类、数组、接口）  |null         |

#### （2）类和对象的使用

```java
public class OOPTest{
	public static void main(String[] args){
		//创建TestClass的对象，即类的实例化，也就是实例化TestClass类
		TestClass testObject = new TestClass();

		//访问TestClass类中的属性
		testObject.field1 = "hello,object";
		testObject.field2 = 20;

		//调用TestClass类中的方法
		testObject.method1();
		testObject.method2();
	}
}
```

#### （3）对象的内存解析

![Java对象的内存解析](./pictures/Java对象的内存解析.png)
* 如果创建了同一个类的多个对象，那么**每个对象都独立的拥有一套类的非 static 属性**，不同对象的非static属性之间**互不影响**
* 对象变量中存放的是一个地址值，可以理解为是**指向存储在堆空间中的对象的实际存储位置的一个指针**

#### （4）匿名对象的使用

### 2.方法的声明和使用

#### （1）方法的声明

```java
/*
	权限修饰符 返回值类型 方法名([形参列表]){
		方法体;
	}
*/
```
|     |无返回值               |有返回值                    |
|-----|-----------------------|---------------------------|
|无形参|void 方法名(){ }       |返回值类型 方法名(){ }       |
|有形参|void 方法名(形参列表){ }|返回值类型 方法名(形参列表){ }|
* 权限修饰符
  * 4种权限修饰符private、public、缺省、protected
  * 规定该方法在多大范围内能够被调用
* 返回值类型
  * 有返回值——在方法声明时指定返回值的类型，同时方法体中**需要使用“return”关键字来返回指定数据类型的数据或常量**，且必须保证**无论如何都会执行一条返回指定数据类型的数据或常量的return语句**，否则编译报错
  * 没有返回值——在方法声明时使用void来表示没有返回值；此时不需要写return语句，但是也可以在方法体内使用语句“ return; ”来作为方法结束的标志，用于方法结束
* 方法名：注意遵循**Java标识符的命名规则和规范**以及**见名知义**
* 形参列表
  * 方法可以声明0个、1个或多个形参
  * 格式：数据类型1 形参1,数据类型2 形参2,...
* 方法体：方法功能的具体体现

#### （2）方法的重载

#### （3）参数的传递

#### （4）注意事项

* 在方法体内的return语句之后，绝对**不能再写任何其它的执行语句**，否则程序报错
* 方法体中可以调用当前类的属性或方法，但是不能在方法中定义方法

### 3.封装与隐藏（封装性）

## 三、Java异常处理

## 四、Java高级编程

### 1.常用类库

```java
//在规定区间[区间下限,区间上限]内取随机数
Math.random() * (区间上限 - 区间下限 + 1) + 区间下限;


```

## 五、JDBC技术

## 六、JavaWeb

## 七、Spring boot框架